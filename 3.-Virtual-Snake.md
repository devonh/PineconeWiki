The virtual snake provides the name-independent identifier routing which efficiently provides robust routing for overlay traffic. It works by effectively arranging all of the nodes on the network into a line, ordered by their public keys, and building paths between keyspace neighbours.

### Descending paths

Each node in the topology has a reference to a descending path. The descending path is the path on the network that leads to the next closest public key to our own in the descending direction (the next lowest key).

There is only one exception to this rule: the node with the lowest key in the network will have no descending path (as there is no lower key to build a descending path).

For a descending path, a node should store the following information:

1. The **Origin public key**, noting which node initiated the path creation;
2. The **Source port**, where the Bootstrap message arrived from;
3. The **Destination port**, where the Bootstrap message was forwarded to next (if applicable);
4. The **Last seen** time, noting when the entry was populated;
5. The **Root public key** and **Root sequence** that the path was set up with.
6. The **Watermark public key** and **Watermark sequence** that the path was set up with.

### Bootstrapping

Bootstrapping is the process of joining the snake topology. Bootstrapping takes place every 5 seconds and takes place in two steps:

1. The bootstrapping node sends a bootstrap message into the network, with their own public key as the “destination” key, which will be routed to the nearest keyspace neighbour;
2. The nearest keyspace neighbour will add the bootstrapping node as their descending neighbour.

The bootstrap message contains the following fields:

<table>
  <tr>
   <td colspan="2" >Bootstrap Sequence
   </td>
  </tr>
  <tr>
   <td>Root public key
   </td>
   <td>Root sequence
   </td>
  </tr>
  <tr>
   <td colspan="2" >Source signature
   </td>
  </tr>
</table>

The **Source signature** is an ed25519 signature covering the **Bootstrap Sequence**, **Root public key** and **Root Sequence** by concatenating them together and signing the result. This enables the remote side to verify that the bootstrap was genuinely initiated by the sending node and has not been forged.

Bootstraps will travel through the network, forwarded **using SNEK routing with bootstrap rules**, towards the destination key, until they arrive at the node that is closest to the destination key. The forwarding logic specifically will not deliver bootstrap messages to the actual destination key, so the bootstrap message will eventually arrive at a “dead end” at the next closest key.

### Handling bootstrap messages

Once the bootstrap message arrives at a dead end, the node will update it's descending node entry if it makes sense to do so (ie. same **Root public key** and **Root sequence** and a closer key than the previous descending entry or an update from our existing descending node).

Before doing anything, the node must ensure that the signature in the **Source signature** field is valid by checking against the **Destination public key**. If the signature is invalid, the bootstrap message should be silently dropped and not processed any further.

Additionally, the node should ensure that the **Root public key** and **Root sequence** of the bootstrap message match those of the most recent root announcement from our chosen parent, if any, or the node’s own public key and sequence number if the node is currently acting as a root node. If this is not true, the bootstrap message should be silently dropped and not processed any further.

Each node along the bootstrapping path should install the bootstrapping node into their routing table.

#### Install route into routing table

Regardless of whether the bootstrap message is considered to have arrived at its intended destination (there is no closer node to route to) or not, a bootstrap message should result in the route being installed into the routing table of each node handling the message.

To install the route into the routing table, the node should either create a new entry or overwrite the existing entry and:

1. Copy the **Origin public key** into the virtual snake index;
2. Copy the bootstrap **Root public key** and **Root sequence** into the appropriate fields;
3. Populate the **Last seen time** with the current time;
4. Populate the **Source port** with a reference to the port that the setup message was received from;
5. Populate the **Destination port** with a reference to the chosen next-hop port, unless the bootstrap message has reached its intended destination, in which case this field should remain empty;
6. Copy the setup **Watermark public key** and **Watermark sequence** into the appropriate fields.

### Next-hop calculation

When using SNEK routing to route towards a certain public key, a number of rules apply in order to calculate the next-hop.

These rules slightly differ based on whether the frame is considered to be a “bootstrap” message. Only “Bootstrap” frames follow the bootstrap rules.

1. Start with a <span style="text-decoration:underline;">best key</span> set to the node’s public key, and a <span style="text-decoration:underline;">best candidate</span> set to the node’s own router port;
2. If the **Destination public key** is equal to the node’s own public key and the frame is not a bootstrap message, handle the packet locally without forwarding;
3. If the node has a chosen parent (i.e. is not a root node) and an announcement has been received from that parent:
    1. If the frame is a bootstrap message and the best key still equals the node’s public key, which should always be the case to begin with, ensure that a worst-case route up to the root is chosen:
        - Set the best key to the chosen parent’s root public key;
        - Set the best candidate to the port through which the parent is reachable;
    2. If the ordering **Best key ＜ Destination public key ＜ Root public key** is true, implying that the target is higher in keyspace than our own key, ensure that a worst-case route up to the root is chosen:
        - Set the best key to the chosen parent’s root public key;
        - Set the best candidate to the port through which the parent is reachable;
    3. For each of the node’s ancestors — that is, public keys that appear in the **Signatures** section of the last received root update from the chosen parent:
        1. If the frame is not a bootstrap message, the candidate ancestor key equals the **Destination public key** and the best key does not equal the **Destination public key**, meaning that we know that the target is one of our ancestors:
            - Set the best key to the ancestor key;
            - Set the best candidate to the port through which the parent is reachable;
        2. If the ordering **Destination public key ＜ Ancestor key ＜ Best key** is true, meaning that we believe one of our ancestors takes us closer to the target:
            - Set the best key to the ancestor key;
            - Set the best candidate to the port through which the parent is reachable;
4. For each of the node’s directly connected peers (first loop):
    1. For each of the connected peer’s ancestors — that is, public keys that appear in the **Signatures** section of the last received root update from this peer:
        1. If the frame is not a bootstrap message, the candidate peer ancestor key equals the **Destination public key** and the best key does not equal the **Destination public key**, meaning that we believe that the target is one of our direct peer’s ancestors:
            - Set the best key to the ancestor key;
            - Set the best candidate to the port through which the peer is reachable;
5. For each of the node’s directly connected peers (second loop):
    1. If the best key equals the connected peer’s public key, i.e. we have previously found the peer’s key as an ancestor of another node but not using the most direct port, we can now refine the path to use the direct connection to that peer instead:
        - Set the best key to the peer’s public key;
        - Set the best candidate to the port through which the peer is reachable;
6. For each of our routing table entries, to look for any transitive paths that may take the packet closer to the target than any of our direct peering knowledge has provided us:
    1. Skip the routing table entry if either of the following conditions are true:
        - The routing table entry has expired;
        - The **Source port** of the routing table entry refers to the local router;
    2. If the frame is not a bootstrap message, the **Path public key** is equal to the **Destination public key** and the best key is not equal to the **Destination public key**:
        - Set the best key to the **Path public key**;
        - Set the best candidate to the **Source port** from the entry;
    3. If the ordering **Destination public key ＜ Path public key ＜ Best key** is true:
        - Set the best key to the **Path public key**;
        - Set the best candidate to the **Source port** from the entry.

If none of the above conditions have matched for the given **Destination public key**, then it is expected that the best candidate will still refer to the local router port, in which case the node is expected to handle the traffic as if it was destined for the local node.

### Routine maintenance

At a specified interval, typically every 1 second, the node should run the following checks:

1. If the descending node entry has expired, that is, the time since the **Last seen** entry has passed 10 seconds, remove the entry;
2. If the descending node entry has different root information, remove the entry;
3. Remove any routing table entries that are older than 10 seconds.
